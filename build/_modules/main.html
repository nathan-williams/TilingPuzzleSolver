

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>main &mdash; Tiling Puzzle Solver 1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Tiling Puzzle Solver 1 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Tiling Puzzle Solver
          

          
          </a>

          
            
            
              <div class="version">
                1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../game.html">Game Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../main.html">The Main Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Example Puzzles</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Tiling Puzzle Solver</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>main</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for main</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/python</span>
<span class="kn">from</span> <span class="nn">game</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">choice</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">islice</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">factorial</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">ImageGrab</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">canvasvg</span>

<div class="viewcode-block" id="getGridOfTileLocationsOnBoard"><a class="viewcode-back" href="../main.html#main.getGridOfTileLocationsOnBoard">[docs]</a><span class="k">def</span> <span class="nf">getGridOfTileLocationsOnBoard</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">export</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Creates a grid containing the tileGroup occupying each space in the grid.</span>

<span class="sd">	:param game: the game containing board and tile information</span>
<span class="sd">	:type game: Game</span>
<span class="sd">	:param export: dictionary of tuples(row,col,x,y,spawned,gridIndex) describing each of the tiles&#39; states</span>
<span class="sd">	:type export: dict&lt;int,tuple(int,int,int,int,bool,int)&gt;</span>
<span class="sd">	:returns: a 2-D array similar to the board; each cell in the grid is None, if no tile is occupying that space, or a tileKey</span>
<span class="sd">	:rtype: 2-D array</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">tileGroups</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">tileGroups</span>
	<span class="n">tiles</span><span class="o">=</span><span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">tiles</span>
	<span class="n">tileLocationsByGroup</span> <span class="o">=</span> <span class="p">{</span><span class="n">tileGroup</span><span class="p">:</span><span class="nb">set</span><span class="p">([</span><span class="n">export</span><span class="p">[</span><span class="n">tileKey</span><span class="p">]</span> <span class="k">for</span> <span class="n">tileKey</span> <span class="ow">in</span> <span class="n">tileGroup</span><span class="p">])</span> <span class="k">for</span> <span class="n">tileGroup</span> <span class="ow">in</span> <span class="n">tileGroups</span><span class="p">}</span>
	<span class="n">tileLocationsOnBoard</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">game</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">grid</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">tileGroup</span> <span class="ow">in</span> <span class="n">tileGroups</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">tileInfo</span> <span class="ow">in</span> <span class="n">tileLocationsByGroup</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">]:</span>
			<span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span> <span class="o">=</span> <span class="n">tileInfo</span>
			<span class="n">grid</span> <span class="o">=</span> <span class="n">tiles</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">distinctGrids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">dr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)):</span>
				<span class="k">for</span> <span class="n">dc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
					<span class="n">tileLocationsOnBoard</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="n">dr</span><span class="p">][</span><span class="n">c</span><span class="o">+</span><span class="n">dc</span><span class="p">]</span> <span class="o">=</span> <span class="n">tileGroup</span> <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">dr</span><span class="p">][</span><span class="n">dc</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39; &#39;</span> <span class="k">else</span> <span class="bp">None</span>
	<span class="k">return</span> <span class="n">tileLocationsOnBoard</span>
</div>
<div class="viewcode-block" id="duplicateSolution"><a class="viewcode-back" href="../main.html#main.duplicateSolution">[docs]</a><span class="k">def</span> <span class="nf">duplicateSolution</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">export</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Determines whether the solution desribed by export has already been found.</span>

<span class="sd">	:param game: the game containing board and tile information</span>
<span class="sd">	:type game: Game</span>
<span class="sd">	:param export: dictionary of tuples(row,col,x,y,spawned,gridIndex) describing each of the tiles&#39; states</span>
<span class="sd">	:type export: dict&lt;int,tuple(int,int,int,int,bool,int)&gt;</span>
<span class="sd">	:returns: True if a solution equivalent to that described by export is already in game.solutions</span>
<span class="sd">	:rtype: 2-D array</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="n">tileGroups</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">tileGroups</span>
	<span class="n">tiles</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">tiles</span>
	<span class="n">gridOfTileLocationsOnBoardA</span> <span class="o">=</span> <span class="n">getGridOfTileLocationsOnBoard</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">export</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">solution</span> <span class="ow">in</span> <span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="p">:</span>
		<span class="n">gridOfTileLocationsOnBoardB</span> <span class="o">=</span> <span class="n">getGridOfTileLocationsOnBoard</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">solution</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
			<span class="n">gridOfTileLocationsOnBoardB</span> <span class="o">=</span> <span class="n">rotateClockwise</span><span class="p">(</span><span class="n">gridOfTileLocationsOnBoardB</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">equivalentGrids</span><span class="p">(</span><span class="n">gridOfTileLocationsOnBoardA</span><span class="p">,</span><span class="n">gridOfTileLocationsOnBoardB</span><span class="p">):</span>
				<span class="k">return</span> <span class="bp">True</span>
		<span class="n">gridOfTileLocationsOnBoardB</span> <span class="o">=</span> <span class="n">flipHorizontally</span><span class="p">(</span><span class="n">gridOfTileLocationsOnBoardB</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
			<span class="n">gridOfTileLocationsOnBoardB</span> <span class="o">=</span> <span class="n">rotateClockwise</span><span class="p">(</span><span class="n">gridOfTileLocationsOnBoardB</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">equivalentGrids</span><span class="p">(</span><span class="n">gridOfTileLocationsOnBoardA</span><span class="p">,</span><span class="n">gridOfTileLocationsOnBoardB</span><span class="p">):</span>
				<span class="k">return</span> <span class="bp">True</span>
	<span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="permute"><a class="viewcode-back" href="../main.html#main.permute">[docs]</a><span class="k">def</span> <span class="nf">permute</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">tileList</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">startrow</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">startcol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Find solutions by permuting through orders of tielList.</span>

<span class="sd">	:param game: the game containing board and tile information</span>
<span class="sd">	:type game: Game</span>
<span class="sd">	:param tileList: the list of tiles</span>
<span class="sd">	:type tileList: list(Tile)</span>
<span class="sd">	:param index: index of tileList to focus on where you should keep permuting from</span>
<span class="sd">	:type index: int</span>
<span class="sd">	:param startrow: the row to start scanning from; defaults to 0</span>
<span class="sd">	:type startrow: int</span>
<span class="sd">	:param startcol: the col to start scanning from; defaults to 0</span>
<span class="sd">	:type startcol: int</span>
<span class="sd">	:returns: True if tileList is a solution</span>
<span class="sd">	:rtype: bool</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">board</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">board</span>
	<span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tileList</span><span class="p">):</span>
		<span class="n">export</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">export</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">duplicateSolution</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">export</span><span class="p">):</span>
			<span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">export</span><span class="p">())</span>
			<span class="c"># do not redraw solutions if more than 100 solutions</span>
			<span class="c"># the rest can be drawn manually by invoking the [Draw Solutions] button</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">game</span><span class="o">.</span><span class="n">maxSolnsDrawn</span><span class="p">:</span>
				<span class="n">game</span><span class="o">.</span><span class="n">readyToDrawSolutions</span> <span class="o">=</span> <span class="bp">True</span>
			<span class="k">return</span> <span class="bp">True</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">tileList</span><span class="p">)):</span>
			<span class="n">tile</span> <span class="o">=</span> <span class="n">tileList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

			<span class="c"># if a solution may exist on this branch, continue permuting</span>
			<span class="c"># otherwise, cut the branch</span>
			<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">distinctGrids</span><span class="p">)):</span>
				<span class="n">grid</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">distinctGrids</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
				<span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="n">nextEmptySpace</span><span class="p">(</span><span class="n">startrow</span><span class="p">,</span><span class="n">startcol</span><span class="p">)</span>

				<span class="n">tile</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>

				<span class="n">colShift</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
					<span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39; &#39;</span><span class="p">:</span>
						<span class="n">colShift</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="k">break</span>

				<span class="k">if</span> <span class="n">board</span><span class="o">.</span><span class="n">validMove</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="o">-</span><span class="n">colShift</span><span class="p">):</span> <span class="c"># not a bad branch</span>
					<span class="n">board</span><span class="o">.</span><span class="n">placeTile</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="o">-</span><span class="n">colShift</span><span class="p">)</span>

					<span class="k">if</span> <span class="n">game</span><span class="o">.</span><span class="n">animate</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
						<span class="n">game</span><span class="o">.</span><span class="n">tileInfo</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">export</span><span class="p">()</span>

					<span class="n">tl</span> <span class="o">=</span> <span class="n">tileList</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">tile</span><span class="p">]</span><span class="o">+</span><span class="n">tileList</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">tileList</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
					<span class="n">solutionFound</span> <span class="o">=</span> <span class="n">permute</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">tl</span><span class="p">,</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span>
					<span class="n">board</span><span class="o">.</span><span class="n">removeTile</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>

					<span class="k">if</span> <span class="n">game</span><span class="o">.</span><span class="n">animate</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
						<span class="n">game</span><span class="o">.</span><span class="n">tileInfo</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">export</span><span class="p">()</span>
	<span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="bruteForce"><a class="viewcode-back" href="../main.html#main.bruteForce">[docs]</a><span class="k">def</span> <span class="nf">bruteForce</span><span class="p">(</span><span class="n">game</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Find solution(s) with brute force method. All possible permutations of the tile list are tried out.</span>
<span class="sd">	The idea was that the tiles could be placed in a well-defined and consistent fashion if the left-most space of the top row of the tile is aligned with the (row,col) of the tile.</span>
<span class="sd">	By this method, only certain orderings of the tiles will result in a filled board.</span>
<span class="sd">	Branches could be cut whenever the tile in its current position in the permutation.</span>

<span class="sd">	:param game: the game containing board and tile information</span>
<span class="sd">	:type game: Game</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

	<span class="n">game</span><span class="o">.</span><span class="n">clearBoard</span><span class="p">()</span>
	<span class="n">game</span><span class="o">.</span><span class="n">solutions</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">tiles</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">tiles</span>
	<span class="n">tileList</span> <span class="o">=</span> <span class="p">[</span><span class="n">tiles</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tiles</span><span class="p">]</span>
	<span class="n">permute</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">tileList</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">game</span><span class="o">.</span><span class="n">readyToDrawSolutions</span> <span class="o">=</span> <span class="bp">True</span>

	<span class="n">stop_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
	<span class="k">print</span> <span class="s">&#39;Execution time:  &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">stop_time</span><span class="o">-</span><span class="n">start_time</span><span class="p">)</span>
	<span class="k">print</span> <span class="s">&#39;Solutions found: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="p">))</span>
	<span class="k">print</span> <span class="s">&#39;&#39;</span>
</div>
<div class="viewcode-block" id="cleanConstraints"><a class="viewcode-back" href="../main.html#main.cleanConstraints">[docs]</a><span class="k">def</span> <span class="nf">cleanConstraints</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">boardConstraints</span><span class="p">,</span><span class="n">tileConstraints</span><span class="p">,</span><span class="n">move</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Updates the constraint lists so that moves that have become invalid after some move was executed are no longer present. These moves may have become invalid because the tile was played already or the tile consumed that space on the board.</span>

<span class="sd">	:param game: the game containing board and tile information</span>
<span class="sd">	:type game: Game</span>
<span class="sd">	:param boardConstraints: contains a constraint for each unoccupied board space; key values are (row,col) pairs corresponding to unoccupied board spaces; values are lists of possible moves in the form of (tileGroup,row,col,gridIndex)</span>
<span class="sd">	:type boardConstraints: dict&lt;tuple(int,int),list((tuple,int,int,int))&gt;</span>
<span class="sd">	:param tileConstraints: contains a constraint for each tile; key values are tileGroups; values are lists of possible moves in the form (row,col,gridIndex)</span>
<span class="sd">	:type tileConstraints: dict&lt;tuple(int,int,...),list((int,int,int))&gt;</span>
<span class="sd">	:param move: describes the move to be executed of the form (tileGroup,row,col,gridIndex)</span>
<span class="sd">	:type move: tuple(tuple,int,int,int)</span>
<span class="sd">	:returns: True if there is a possible move to satisfy every board constraint; False if there is a board constraint that cannot be satisfied with any available tiles</span>
<span class="sd">	:rtype: bool</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">placedTileGroup</span><span class="p">,</span><span class="n">gridIndex</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">move</span>
	<span class="n">placedTile</span> <span class="o">=</span> <span class="n">placedTileGroup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">newTileGroup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">placedTileGroup</span> <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">placedTile</span><span class="p">)</span>
	<span class="n">board</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">board</span>
	<span class="n">tiles</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">tiles</span>
	<span class="n">tile</span> <span class="o">=</span> <span class="n">tiles</span><span class="p">[</span><span class="n">placedTile</span><span class="p">]</span>

	<span class="c"># remove board spaces that were filled by the placed tile in boardConstraints</span>
	<span class="n">filledSpaces</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">dr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">grid</span><span class="p">)):</span>
		<span class="k">for</span> <span class="n">dc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
			<span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">dr</span><span class="p">][</span><span class="n">dc</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39; &#39;</span><span class="p">:</span>
				<span class="c"># occurs if branching with multiple moves and moves conflict</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span><span class="n">col</span><span class="o">+</span><span class="n">dc</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">:</span>
					<span class="k">return</span> <span class="bp">False</span>
				<span class="k">del</span> <span class="n">boardConstraints</span><span class="p">[(</span><span class="n">row</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span><span class="n">col</span><span class="o">+</span><span class="n">dc</span><span class="p">)]</span>
				<span class="n">filledSpaces</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">row</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span><span class="n">col</span><span class="o">+</span><span class="n">dc</span><span class="p">))</span>
	<span class="n">filledSpaces</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">filledSpaces</span><span class="p">)</span>

	<span class="c"># POSSIBLE FUTURE IMPROVEMENT</span>
	<span class="c"># remove moves that are just reflections / rotations</span>
	<span class="c"># if board.horizontalSymmetry:</span>
	<span class="c"># 	pass</span>
	<span class="c"># if board.verticalSymmetry:</span>
	<span class="c"># 	pass</span>
	<span class="c"># for n in range(3):</span>
	<span class="c"># 	if board.rotationalSymmetry[n]:</span>
	<span class="c"># 		pass</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">gridIndex</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tileConstraints</span><span class="p">[</span><span class="n">placedTileGroup</span><span class="p">]:</span>
		<span class="c"># remove placed tile location from its tile gorup in tileConstraints</span>
		<span class="n">tileConstraints</span><span class="p">[</span><span class="n">placedTileGroup</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">gridIndex</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">))</span>
		<span class="c"># remove placed tile from its tile group in tileConstraints</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTileGroup</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">tileConstraints</span><span class="p">[</span><span class="n">newTileGroup</span><span class="p">]</span> <span class="o">=</span> <span class="n">tileConstraints</span><span class="p">[</span><span class="n">placedTileGroup</span><span class="p">]</span>
		<span class="k">del</span> <span class="n">tileConstraints</span><span class="p">[</span><span class="n">placedTileGroup</span><span class="p">]</span>

	<span class="c"># remove placed tile from its tile groups in boardConstraints</span>
	<span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">:</span>
		<span class="n">constraint</span> <span class="o">=</span> <span class="n">boardConstraints</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
			<span class="n">tileGroup</span><span class="p">,</span><span class="n">gridIndex</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">constraint</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">tileGroup</span> <span class="o">==</span> <span class="n">placedTileGroup</span><span class="p">:</span>
				<span class="n">constraint</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">newTileGroup</span><span class="p">,</span><span class="n">gridIndex</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTileGroup</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">del</span> <span class="n">constraint</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
					<span class="c"># bad branch; no tile can fill this space on the board</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
						<span class="k">return</span> <span class="bp">False</span>
	
	<span class="c"># remove possible tile positions in tileConstraints that are not possible anymore</span>
	<span class="k">for</span> <span class="n">tileGroup</span> <span class="ow">in</span> <span class="n">tileConstraints</span><span class="p">:</span>
		<span class="n">constraint</span> <span class="o">=</span> <span class="n">tileConstraints</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
			<span class="n">gridIndex</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">constraint</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
			<span class="n">tileKey</span> <span class="o">=</span> <span class="n">tileGroup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">tile</span> <span class="o">=</span> <span class="n">tiles</span><span class="p">[</span><span class="n">tileKey</span><span class="p">]</span>
			<span class="n">tile</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">distinctGrids</span><span class="p">[</span><span class="n">gridIndex</span><span class="p">]</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">board</span><span class="o">.</span><span class="n">validMove</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
				<span class="k">del</span> <span class="n">constraint</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
				<span class="k">for</span> <span class="n">dr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">grid</span><span class="p">)):</span>
					<span class="k">for</span> <span class="n">dc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
						<span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">dr</span><span class="p">][</span><span class="n">dc</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39; &#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span><span class="n">col</span><span class="o">+</span><span class="n">dc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">:</span>
							<span class="n">boardConstraints</span><span class="p">[(</span><span class="n">row</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span><span class="n">col</span><span class="o">+</span><span class="n">dc</span><span class="p">)]</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">tileGroup</span><span class="p">,</span><span class="n">gridIndex</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">))</span>
							<span class="c"># bad branch; no tile can fill this space on the board</span>
							<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">boardConstraints</span><span class="p">[(</span><span class="n">row</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span><span class="n">col</span><span class="o">+</span><span class="n">dc</span><span class="p">)])</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
								<span class="k">return</span> <span class="bp">False</span>

	<span class="c"># remove tiles that cannot be placed anywhere anymore</span>
	<span class="c"># note that this does not necessarily mean bad branch</span>
	<span class="c">#     in the case that there are extra tiles</span>
	<span class="n">tileConstraints</span> <span class="o">=</span> <span class="p">{</span><span class="n">tileGroup</span><span class="p">:</span><span class="n">tileConstraints</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">]</span> <span class="k">for</span> <span class="n">tileGroup</span> <span class="ow">in</span> <span class="n">tileConstraints</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tileConstraints</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>

	<span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="branch"><a class="viewcode-back" href="../main.html#main.branch">[docs]</a><span class="k">def</span> <span class="nf">branch</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">boardConstraints</span><span class="p">,</span><span class="n">tileConstraints</span><span class="p">,</span><span class="n">move</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Executes a move, updates the constraint lists, and continues branching if there is still at least one valid move to satisfy every board constraint.</span>


<span class="sd">	:param game: the game containing board and tile information</span>
<span class="sd">	:type game: Game</span>
<span class="sd">	:param boardConstraints: contains a constraint for each unoccupied board space; key values are (row,col) pairs corresponding to unoccupied board spaces; values are lists of possible moves in the form of (tileGroup,row,col,gridIndex)</span>
<span class="sd">	:type boardConstraints: dict&lt;tuple(int,int),list((tuple,int,int,int))&gt;</span>
<span class="sd">	:param tileConstraints: contains a constraint for each tile; key values are tileGroups; values are lists of possible moves in the form (row,col,gridIndex)</span>
<span class="sd">	:type tileConstraints: dict&lt;tuple(int,int,...),list((int,int,int))&gt;</span>
<span class="sd">	:param move: describes the move to be executed of the form (tileGroup,row,col,gridIndex)</span>
<span class="sd">	:type move: tuple(tuple,int,int,int)</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">tileGroup</span><span class="p">,</span><span class="n">gridIndex</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">move</span>

	<span class="n">tileKey</span> <span class="o">=</span> <span class="n">tileGroup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">board</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">board</span>
	<span class="n">tiles</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">tiles</span>
	<span class="n">tile</span> <span class="o">=</span> <span class="n">tiles</span><span class="p">[</span><span class="n">tileKey</span><span class="p">]</span>

	<span class="n">tile</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">distinctGrids</span><span class="p">[</span><span class="n">gridIndex</span><span class="p">]</span>
	<span class="n">board</span><span class="o">.</span><span class="n">placeTile</span><span class="p">(</span><span class="n">tiles</span><span class="p">[</span><span class="n">tileKey</span><span class="p">],</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">game</span><span class="o">.</span><span class="n">animate</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
		<span class="n">game</span><span class="o">.</span><span class="n">tileInfo</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">export</span><span class="p">()</span>

	<span class="c"># update boardConstraints</span>
	<span class="n">bcClone</span> <span class="o">=</span> <span class="p">{</span><span class="n">foo</span><span class="p">:[</span><span class="n">bar</span> <span class="k">for</span> <span class="n">bar</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">[</span><span class="n">foo</span><span class="p">]]</span> <span class="k">for</span> <span class="n">foo</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">}</span>
	<span class="n">tcClone</span> <span class="o">=</span> <span class="p">{</span><span class="n">foo</span><span class="p">:[</span><span class="n">bar</span> <span class="k">for</span> <span class="n">bar</span> <span class="ow">in</span> <span class="n">tileConstraints</span><span class="p">[</span><span class="n">foo</span><span class="p">]]</span> <span class="k">for</span> <span class="n">foo</span> <span class="ow">in</span> <span class="n">tileConstraints</span><span class="p">}</span>
	<span class="n">success</span> <span class="o">=</span> <span class="n">cleanConstraints</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">bcClone</span><span class="p">,</span><span class="n">tcClone</span><span class="p">,</span><span class="n">move</span><span class="p">)</span>

	<span class="c"># continue dancing if not a bad branch</span>
	<span class="n">solved</span> <span class="o">=</span> <span class="bp">False</span>
	<span class="k">if</span> <span class="n">success</span><span class="p">:</span>
		<span class="n">solved</span> <span class="o">=</span> <span class="n">dance</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">bcClone</span><span class="p">,</span><span class="n">tcClone</span><span class="p">)</span>

	<span class="c"># revert board state</span>
	<span class="n">board</span><span class="o">.</span><span class="n">removeTile</span><span class="p">(</span><span class="n">tiles</span><span class="p">[</span><span class="n">tileKey</span><span class="p">])</span>
	<span class="k">if</span> <span class="n">game</span><span class="o">.</span><span class="n">animate</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
		<span class="n">game</span><span class="o">.</span><span class="n">tileInfo</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">export</span><span class="p">()</span>

	<span class="k">if</span> <span class="n">solved</span> <span class="ow">and</span> <span class="n">game</span><span class="o">.</span><span class="n">findJustOne</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">game</span><span class="o">.</span><span class="n">maxSolnsDrawn</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">True</span>

<span class="c"># check for duplicate solutions manually because when tiles aren&#39;t played, then duplicates appear</span>
<span class="c"># It is probably possible to add an optimization for removing moves corresponding to</span>
<span class="c"># rotations / flips / reflections of the entire board.</span></div>
<div class="viewcode-block" id="dance"><a class="viewcode-back" href="../main.html#main.dance">[docs]</a><span class="k">def</span> <span class="nf">dance</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">boardConstraints</span><span class="p">,</span><span class="n">tileConstraints</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Dances through the board constraints looking for tile solutions. The next move is chosen using the list of possible moves for the constraint with the least number of possible moves.</span>
<span class="sd">	For each of those possible moves, a branch is spawned and explored. If the board can be filled with the other tiles besides the one that is</span>
<span class="sd">	being branched with, then we will still have to branch again after eliminating that tile.</span>

<span class="sd">	:param game: the game containing board and tile information</span>
<span class="sd">	:type game: Game</span>
<span class="sd">	:param boardConstraints: contains a constraint for each unoccupied board space; key values are (row,col) pairs corresponding to unoccupied board spaces; values are lists of possible moves in the form of (tileGroup,row,col,gridIndex)</span>
<span class="sd">	:type boardConstraints: dict&lt;tuple(int,int),list((tuple,int,int,int))&gt;</span>
<span class="sd">	:param tileConstraints: contains a constraint for each tile; key values are tileGroups; values are lists of possible moves in the form (row,col,gridIndex)</span>
<span class="sd">	:type tileConstraints: dict&lt;tuple(int,int,...),list((int,int,int))&gt;</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c"># reapeat until board has no empty slots that have to be filled</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">boardConstraints</span><span class="p">:</span>
		<span class="n">export</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">export</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">duplicateSolution</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">export</span><span class="p">):</span>
			<span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">export</span><span class="p">)</span>
			<span class="c"># do not redraw solutions if more than 100 solutions</span>
			<span class="c"># the rest can be drawn manually by invoking the [Draw Solutions] button</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">game</span><span class="o">.</span><span class="n">maxSolnsDrawn</span><span class="p">:</span>
				<span class="n">game</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">selectedFile</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">:]</span>
				<span class="n">f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">())))</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">solutions</span><span class="se">\\</span><span class="s">&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="p">))</span><span class="o">+</span><span class="s">&quot;.svg&quot;</span>
				<span class="n">d</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
				<span class="k">try</span><span class="p">:</span>
				    <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
				<span class="k">except</span><span class="p">:</span>
				    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
				<span class="n">canvasvg</span><span class="o">.</span><span class="n">saveall</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">game</span><span class="o">.</span><span class="n">canvas1</span><span class="p">)</span>

				<span class="n">game</span><span class="o">.</span><span class="n">readyToDrawSolutions</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="k">return</span> <span class="bp">True</span>

	<span class="n">board</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">board</span>
	<span class="n">tileBucket</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span>
	<span class="n">tiles</span> <span class="o">=</span> <span class="n">tileBucket</span><span class="o">.</span><span class="n">tiles</span>
	<span class="n">tileGroups</span> <span class="o">=</span> <span class="n">tileBucket</span><span class="o">.</span><span class="n">tileGroups</span>

	<span class="n">coord</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">boardConstraints</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">c</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">boardConstraints</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span> <span class="c"># get boardConstraint with least number of candidates</span>
	<span class="n">tileGroup</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tileConstraints</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">tg</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">tileConstraints</span><span class="p">[</span><span class="n">tg</span><span class="p">])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">tg</span><span class="p">))</span> <span class="c"># get tileConstraint with least number of candidates per tileGroup memeber</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tileConstraints</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tileConstraints</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">tileGroup</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">boardConstraints</span><span class="p">[</span><span class="n">coord</span><span class="p">]):</span>
		<span class="k">for</span> <span class="n">gridIndex</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="ow">in</span> <span class="n">tileConstraints</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">]:</span>
			<span class="n">solved</span> <span class="o">=</span> <span class="n">branch</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">boardConstraints</span><span class="p">,</span><span class="n">tileConstraints</span><span class="p">,(</span><span class="n">tileGroup</span><span class="p">,</span><span class="n">gridIndex</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">))</span>
			<span class="k">if</span> <span class="n">solved</span> <span class="ow">and</span> <span class="n">game</span><span class="o">.</span><span class="n">findJustOne</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">game</span><span class="o">.</span><span class="n">maxSolnsDrawn</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">True</span>
		<span class="n">canSolveWithoutTile</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">boardConstraints</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tiles</span><span class="p">[</span><span class="n">tg</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">size</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">tg</span><span class="p">)</span> <span class="k">for</span> <span class="n">tg</span> <span class="ow">in</span> <span class="n">tileConstraints</span><span class="p">])</span> <span class="o">-</span>  <span class="n">tiles</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">size</span>
		<span class="k">if</span> <span class="n">canSolveWithoutTile</span><span class="p">:</span>
			<span class="c"># remove the branch that was explored from constraint lists</span>
			<span class="n">newTileGroup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">tileGroup</span> <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">tileGroup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newTileGroup</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">tileConstraints</span><span class="p">[</span><span class="n">newTileGroup</span><span class="p">]</span> <span class="o">=</span> <span class="n">tileConstraints</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">]</span>
				<span class="n">boardConstraints</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:[(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">tileGroup</span> <span class="k">else</span> <span class="p">(</span><span class="n">newTileGroup</span><span class="p">,</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">}</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">boardConstraints</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:[(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">tileGroup</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">}</span>
			<span class="k">del</span> <span class="n">tileConstraints</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">boardConstraints</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">return</span>
			<span class="n">solved</span> <span class="o">=</span> <span class="n">dance</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">boardConstraints</span><span class="p">,</span><span class="n">tileConstraints</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">solved</span> <span class="ow">and</span> <span class="n">game</span><span class="o">.</span><span class="n">findJustOne</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">game</span><span class="o">.</span><span class="n">maxSolnsDrawn</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">True</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">move</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">[</span><span class="n">coord</span><span class="p">]:</span>
			<span class="n">solved</span> <span class="o">=</span> <span class="n">branch</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">boardConstraints</span><span class="p">,</span><span class="n">tileConstraints</span><span class="p">,</span><span class="n">move</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">solved</span> <span class="ow">and</span> <span class="n">game</span><span class="o">.</span><span class="n">findJustOne</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">game</span><span class="o">.</span><span class="n">maxSolnsDrawn</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="createConstraintLists"><a class="viewcode-back" href="../main.html#main.createConstraintLists">[docs]</a><span class="k">def</span> <span class="nf">createConstraintLists</span><span class="p">(</span><span class="n">game</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Creates the initial constraint lists by compiling a list of all possible moves that can satisfy a certain constraint. A board constraints list, in which each constraint corresponds</span>
<span class="sd">	to a space on the board, and a tile constraint list, in which each constraint corresponds to a tile in the tile bucket, are both created.</span>

<span class="sd">	:param game: the game containing board and tile information</span>
<span class="sd">	:type game: Game</span>
<span class="sd">	:returns: the two dictionaries, boardConstraints and tileConstraints</span>
<span class="sd">	:rtype: tuple(dict,dict)</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">board</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">board</span>
	<span class="n">tiles</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">tiles</span>
	<span class="n">tileGroups</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">tileGroups</span>
	<span class="n">boardConstraints</span> <span class="o">=</span> <span class="p">{(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">):[]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span> <span class="k">if</span> <span class="n">board</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39; &#39;</span><span class="p">}</span>
	<span class="n">tileConstraints</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">tileGroup</span> <span class="ow">in</span> <span class="n">tileGroups</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">grid</span><span class="p">)):</span>
			<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
				<span class="n">tileKey</span> <span class="o">=</span> <span class="n">tileGroup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
				<span class="n">tile</span> <span class="o">=</span> <span class="n">tiles</span><span class="p">[</span><span class="n">tileKey</span><span class="p">]</span>
				<span class="k">for</span> <span class="n">gridIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">distinctGrids</span><span class="p">)):</span>
					<span class="n">tile</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">distinctGrids</span><span class="p">[</span><span class="n">gridIndex</span><span class="p">]</span>
					<span class="k">if</span> <span class="n">board</span><span class="o">.</span><span class="n">validMove</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
						<span class="k">if</span> <span class="n">tileGroup</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tileConstraints</span><span class="p">:</span>
							<span class="n">tileConstraints</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
						<span class="n">tileConstraints</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">gridIndex</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">))</span>
						<span class="k">for</span> <span class="n">dr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">grid</span><span class="p">)):</span>
							<span class="k">for</span> <span class="n">dc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
								<span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">dr</span><span class="p">][</span><span class="n">dc</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39; &#39;</span><span class="p">:</span>
									<span class="n">boardConstraints</span><span class="p">[(</span><span class="n">r</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span><span class="n">c</span><span class="o">+</span><span class="n">dc</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tileGroup</span><span class="p">,</span><span class="n">gridIndex</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">boardConstraints</span><span class="p">,</span><span class="n">tileConstraints</span>
</div>
<div class="viewcode-block" id="dancingLinks"><a class="viewcode-back" href="../main.html#main.dancingLinks">[docs]</a><span class="k">def</span> <span class="nf">dancingLinks</span><span class="p">(</span><span class="n">game</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Dancing links is a more creative approach to searching the solution space. The name may be misleading, as the acutal &quot;Dancing Links&quot; algorithm was not implemented here. More over, </span>
<span class="sd">	&quot;Dancing Links&quot; is less of a true algorithm and more of an exploitation of the linked list data structure. This algorithm relies on minimizing the branching factor at each </span>
<span class="sd">	decision point. As such, when a branch is cut, more possibilities can be eliminated at one time. Although the added sophistication requires extra processing between moves, </span>
<span class="sd">	the benefits outweight the costs in this case.</span>

<span class="sd">	:param game: the game containing board and tile information</span>
<span class="sd">	:type game: Game</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

	<span class="n">game</span><span class="o">.</span><span class="n">clearBoard</span><span class="p">()</span>
	<span class="n">game</span><span class="o">.</span><span class="n">solutions</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">boardConstraints</span><span class="p">,</span><span class="n">tileConstraints</span> <span class="o">=</span> <span class="n">createConstraintLists</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>

	<span class="n">dance</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">boardConstraints</span><span class="p">,</span><span class="n">tileConstraints</span><span class="p">)</span>
	<span class="n">game</span><span class="o">.</span><span class="n">readyToDrawSolutions</span> <span class="o">=</span> <span class="bp">True</span>

	<span class="n">stop_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
	<span class="k">print</span> <span class="s">&#39;Execution time: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">stop_time</span><span class="o">-</span><span class="n">start_time</span><span class="p">)</span>
	<span class="k">print</span> <span class="s">&#39;Solutions found: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">solutions</span><span class="p">))</span>
	<span class="k">print</span> <span class="s">&#39;&#39;</span>
</div>
<div class="viewcode-block" id="printTileConstraints"><a class="viewcode-back" href="../main.html#main.printTileConstraints">[docs]</a><span class="k">def</span> <span class="nf">printTileConstraints</span><span class="p">(</span><span class="n">tileConstraints</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Used for debugging. Prints the tile constraints dictionary.</span>

<span class="sd">	:param tileConstraints: dictionary of tile constraints</span>
<span class="sd">	:type tileConstraints: dict</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">print</span> <span class="s">&#39;Tile Constraints&#39;</span>
	<span class="k">for</span> <span class="n">tileGroup</span> <span class="ow">in</span> <span class="n">tileConstraints</span><span class="p">:</span>
		<span class="k">print</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tileGroup</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tileConstraints</span><span class="p">[</span><span class="n">tileGroup</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="printBoardConstraints"><a class="viewcode-back" href="../main.html#main.printBoardConstraints">[docs]</a><span class="k">def</span> <span class="nf">printBoardConstraints</span><span class="p">(</span><span class="n">boardConstraints</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Used for debugging. Prints the board constraints dictionary.</span>

<span class="sd">	:param tileConstraints: dictionary of board constraints</span>
<span class="sd">	:type tileConstraints: dict</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">print</span> <span class="s">&#39;Board Constraints&#39;</span>
	<span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">:</span>
		<span class="k">print</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">row </span><span class="si">%d</span><span class="s">, col </span><span class="si">%d</span><span class="s">:&#39;</span><span class="o">%</span><span class="n">coord</span>
		<span class="k">for</span> <span class="n">possibleMove</span> <span class="ow">in</span> <span class="n">boardConstraints</span><span class="p">[</span><span class="n">coord</span><span class="p">]:</span>
			<span class="k">print</span> <span class="s">&#39;</span><span class="se">\t\t</span><span class="s">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">possibleMove</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="doInExternalThread"><a class="viewcode-back" href="../main.html#main.doInExternalThread">[docs]</a><span class="k">def</span> <span class="nf">doInExternalThread</span><span class="p">(</span><span class="n">game</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Spawns a daemon thread to execute the given function if the multithread setting is on; otherwise the main thread is used. The main thread is much faster, but the GUI will freeze during long </span>
<span class="sd">	computations if the main thread is used.</span>

<span class="sd">	:param game: the game containing board and tile information</span>
<span class="sd">	:type game: Game</span>
<span class="sd">	:param f: function to be executed</span>
<span class="sd">	:type f: func</span>
<span class="sd">	:param a: args for the function</span>
<span class="sd">	:type a: tuple</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">game</span><span class="o">.</span><span class="n">multithread</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">a</span><span class="p">)</span>
		<span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="nb">apply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="load"><a class="viewcode-back" href="../main.html#main.load">[docs]</a><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">game</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Loads the currently selected file and updates the display.</span>

<span class="sd">	:param game: the game containing board and tile information</span>
<span class="sd">	:type game: Game</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">game</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">selectedFile</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
	<span class="n">game</span><span class="o">.</span><span class="n">tileInfo</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">export</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="diagnostics"><a class="viewcode-back" href="../main.html#main.diagnostics">[docs]</a><span class="k">def</span> <span class="nf">diagnostics</span><span class="p">(</span><span class="n">game</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Automatically time all puzzle solves under current settings. Dancing Links is used instead of brute force beause otherwise many of the puzzles would not finish.</span>

<span class="sd">	:param game: the game containing board and tile information</span>
<span class="sd">	:type game: Game</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">path</span> <span class="ow">in</span> <span class="n">game</span><span class="o">.</span><span class="n">files</span><span class="p">:</span>
		<span class="n">game</span><span class="o">.</span><span class="n">selectedFile</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
		<span class="n">game</span><span class="o">.</span><span class="n">loadingOutsideMainThread</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="n">game</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
		<span class="n">game</span><span class="o">.</span><span class="n">loadingOutsideMainThread</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="n">game</span><span class="o">.</span><span class="n">tileInfo</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">export</span><span class="p">()</span>
		<span class="k">print</span> <span class="n">name</span>
		<span class="n">dancingLinks</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="main"><a class="viewcode-back" href="../main.html#main.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Initializes the functional section of the user interface and starts TKinter&#39;s main graphics loop.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&#39;BOARD_WIDTH&#39;</span> <span class="p">:</span> <span class="mi">400</span><span class="p">,</span>
		<span class="s">&#39;SEPARATOR_WIDTH&#39;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="s">&#39;PILE_WIDTH&#39;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="s">&#39;TILELIST_WIDTH&#39;</span> <span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
		<span class="s">&#39;CANVAS_HEIGHT&#39;</span> <span class="p">:</span> <span class="mi">400</span><span class="p">,</span>
		<span class="s">&#39;BORDER_WIDTH&#39;</span> <span class="p">:</span> <span class="mi">40</span><span class="p">,</span>
		<span class="s">&#39;GRIDLINE_WIDTH&#39;</span> <span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
		<span class="s">&#39;SOLN_LIST_HEIGHT&#39;</span> <span class="p">:</span> <span class="mi">100</span>
	<span class="p">}</span>
	<span class="n">game</span> <span class="o">=</span> <span class="n">Game</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
	<span class="n">root</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">root</span>

	<span class="c"># Bottom frame</span>
	<span class="n">bottomFrame</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">bottomFrame</span>
	<span class="n">topRow</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">bottomFrame</span><span class="p">)</span>
	<span class="n">bottomRow</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">bottomFrame</span><span class="p">)</span>

	<span class="n">Button</span><span class="p">(</span><span class="n">topRow</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&#39;Run Diagnostics&#39;</span><span class="p">,</span> <span class="n">command</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span><span class="n">doInExternalThread</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">diagnostics</span><span class="p">,</span><span class="nb">tuple</span><span class="p">([</span><span class="n">game</span><span class="p">])))</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">LEFT</span><span class="p">)</span>
	<span class="n">Button</span><span class="p">(</span><span class="n">topRow</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&#39;Dancing Links&#39;</span><span class="p">,</span> <span class="n">command</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span><span class="n">doInExternalThread</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">dancingLinks</span><span class="p">,</span><span class="nb">tuple</span><span class="p">([</span><span class="n">game</span><span class="p">])))</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">LEFT</span><span class="p">)</span>
	<span class="n">Button</span><span class="p">(</span><span class="n">topRow</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&#39;Brute Force&#39;</span><span class="p">,</span> <span class="n">command</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span><span class="n">doInExternalThread</span><span class="p">(</span><span class="n">game</span><span class="p">,</span><span class="n">bruteForce</span><span class="p">,</span><span class="nb">tuple</span><span class="p">([</span><span class="n">game</span><span class="p">])))</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">LEFT</span><span class="p">)</span>
	<span class="n">Button</span><span class="p">(</span><span class="n">topRow</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&#39;Draw Solutions&#39;</span><span class="p">,</span> <span class="n">command</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span><span class="n">game</span><span class="o">.</span><span class="n">drawSolutions</span><span class="p">())</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">LEFT</span><span class="p">)</span>
	<span class="n">Checkbutton</span><span class="p">(</span><span class="n">bottomRow</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&quot;Find just one solution&quot;</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="n">game</span><span class="o">.</span><span class="n">findJustOne</span><span class="p">)</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">LEFT</span><span class="p">)</span>
	<span class="n">Checkbutton</span><span class="p">(</span><span class="n">bottomRow</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&quot;Can flip tiles&quot;</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="n">game</span><span class="o">.</span><span class="n">canFlipTiles</span><span class="p">)</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">LEFT</span><span class="p">)</span>
	<span class="n">Checkbutton</span><span class="p">(</span><span class="n">bottomRow</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&quot;Animate&quot;</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="n">game</span><span class="o">.</span><span class="n">animate</span><span class="p">)</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">LEFT</span><span class="p">)</span>
	<span class="n">Checkbutton</span><span class="p">(</span><span class="n">bottomRow</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&quot;Multithread&quot;</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="n">game</span><span class="o">.</span><span class="n">multithread</span><span class="p">)</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">LEFT</span><span class="p">)</span>
	<span class="n">Button</span><span class="p">(</span><span class="n">bottomRow</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&#39;Load&#39;</span><span class="p">,</span> <span class="n">command</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span><span class="n">load</span><span class="p">(</span><span class="n">game</span><span class="p">))</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">LEFT</span><span class="p">)</span>
	<span class="nb">apply</span><span class="p">(</span><span class="n">OptionMenu</span><span class="p">,</span> <span class="p">(</span><span class="n">bottomRow</span><span class="p">,</span><span class="n">game</span><span class="o">.</span><span class="n">selectedFile</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">game</span><span class="o">.</span><span class="n">files</span><span class="p">))</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">LEFT</span><span class="p">)</span>

	<span class="n">topRow</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">TOP</span><span class="p">)</span>
	<span class="n">bottomRow</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">BOTTOM</span><span class="p">)</span>

	<span class="n">game</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">selectedFile</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
	<span class="n">game</span><span class="o">.</span><span class="n">tileInfo</span> <span class="o">=</span> <span class="n">game</span><span class="o">.</span><span class="n">tileBucket</span><span class="o">.</span><span class="n">export</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">update</span><span class="p">():</span>
		<span class="n">game</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">tileInfo</span><span class="p">)</span>
		<span class="n">game</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">after</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span><span class="n">update</span><span class="p">)</span>
	<span class="n">game</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">after</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">update</span><span class="p">)</span>
	
	<span class="n">root</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="s">&#39;+0+0&#39;</span><span class="p">)</span>
	<span class="n">root</span><span class="o">.</span><span class="n">protocol</span><span class="p">(</span><span class="s">&quot;WM_DELETE_WINDOW&quot;</span><span class="p">,</span> <span class="n">quit</span><span class="p">)</span>
	<span class="n">root</span><span class="o">.</span><span class="n">mainloop</span><span class="p">()</span>
</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
	<span class="n">main</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Nathan Williams.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>